from typing import Tuple
from pathlib import Path

import numpy as np
from scipy.interpolate import RegularGridInterpolator
import polars as pl

from numpy.typing import ArrayLike
from ..Utilities.Geometry import EquidistantRectGridEven
from .poisson_pressure_nonlinear import NonLinearPoisson

CACHE_FN = Path(__file__).parent.parent.parent / "p_NL.csv"


def load_cache(cache_fn: Path = CACHE_FN) -> Tuple[ArrayLike, ...]:
    df = pl.read_csv(cache_fn)

    dps = df.to_numpy()[:, 0]
    xs = np.array(df.columns[1:], dtype=float)
    ps = df.to_numpy()[:, 1:]

    return dps, xs, ps


def save_cache(
    dps: ArrayLike, xs: ArrayLike, ps: ArrayLike, cache_fn: Path = CACHE_FN
) -> None:
    schema = ["dp"] + [f"{x:.2f}" for x in xs]
    data = np.hstack((np.round(dps[:, np.newaxis], 2), ps))
    df = pl.DataFrame(data, schema=schema)

    df.write_csv(cache_fn)


class NonlinearADPressureField:
    """
    This class represents the nonlinear centerline pressure field generated by
    solving a nonlinear Poisson equation on a rectangular grid.
    """

    def __init__(
        self,
        Lx=60.0,
        Ly=60.0,
        dx=0.1,
        dy=1.0,
        ddp=0.05,
        iterations=3,
        relax=0.0,
        accumulate=True,
    ):
        """
        Lx (float) : x-dimension of the rectangular grid
        Ly (float) : y-dimension of the rectangular grid
        dx (float) : x-spacing of grid points
        dy (float) : y-spacing of grid points
        ddp (float) : dp spacing for interpolation table
        iterations (int) : number of iterations to solve PDE
        """
        self.geometry = EquidistantRectGridEven(Lx, Ly, dx, dy)
        self.max_iter = iterations + 1
        self.relax = relax

        dps, xs, ps = self._generate_pressure_table(
            ddp, dx, xmax=Lx / 4, accumulate=accumulate, relax=relax
        )

        self.interpolator = RegularGridInterpolator(
            [dps, xs], ps, bounds_error=False, fill_value=0
        )

    def _generate_pressure_table(
        self,
        ddp: float,
        dx: float,
        xmax=15,
        accumulate=True,
        relax=0.0,
    ) -> Tuple[ArrayLike, ...]:
        """
        Generate interpolation table by solving nonlinear PDE

        ddp (float) : dp spacing for interpolation table
        dx (float) : streamwise x-spacing for interpolation table
        xmax (float) : max x-value for interpolation table

        Returns tuple of arrays:
            dps (np.ndarray): dp values for interpolation
            xs (np.ndarray): x values for interpolation
            ps (np.ndarray): pressure values for interpolation
        """
        # Define dp and x_0 grid
        dps = np.arange(0, 1 + ddp, ddp)
        xs = np.arange(0, xmax, dx)

        # Generate nonlinear pressure table
        ps = np.zeros((len(dps), len(xs)))
        for i, dp in enumerate(dps):
            ps[i, :] = self._solve_pressure(dp, xs, accumulate=accumulate, relax=relax)

        # clip non-linear pressure to below zero.
        ps = np.minimum(ps, 0)

        return dps, xs, ps

    def _solve_pressure(
        self, dp: float, x: ArrayLike, accumulate=True, relax=0.0
    ) -> ArrayLike:
        """
        Solves for the centerline pressure term at the given x locations (can be a
        vector). Note: dp cannot be a vector in this implementation. It must be
        a float.

        dp (float) : pressure drop over actuator disk
        x (ArrayLike) : streamwise x locations

        Returns:
            ArrayLike: centerline pressure values at x
        """

        fields = []

        def callback(object, i):
            fields.append(object.sol_NL.p)

        pde = NonLinearPoisson(self.geometry, dP=dp)
        sol_tot, sol_f, sol_g = pde.solve(
            max_iter=self.max_iter, relax=relax, callback=callback
        )

        if accumulate:
            combined_field = np.min(fields, axis=0)
        else:
            combined_field = fields[-1]

        x_ = self.geometry.x
        y_ = self.geometry.y

        # Create interpolator. Convert radius-based calculations to diameter-based
        interpolator = RegularGridInterpolator(
            [x_ / 2, y_], combined_field, bounds_error=False, fill_value=0
        )

        out = interpolator((x, 0), method="linear")
        return out

    def get_pressure(self, dp: ArrayLike, x0: ArrayLike) -> ArrayLike:
        """
        Returns the centerline pressure at the given x location from the
        generated interpolation table, where dp and x0 can be vectors.

        dp (ArrayLike) : values for pressure drop over actuator disk
        x0 (ArrayLike) : streamwise x locations

        Returns:
            ArrayLike: interpolated centerline pressure values
        """
        return self.interpolator((dp, x0))


class AccumulatedNonlinearADPressureField(NonlinearADPressureField):
    def __init__(
        self,
        Lx=60.0,
        Ly=60.0,
        dx=0.1,
        dy=1.0,
        ddp=0.1,
        iterations=3,
        relaxations=[0.0, 0.1, 0.2],
        cache_fn: Path = CACHE_FN,
    ):
        """
        Lx (float) : x-dimension of the rectangular grid
        Ly (float) : y-dimension of the rectangular grid
        dx (float) : x-spacing of grid points
        dy (float) : y-spacing of grid points
        ddp (float) : dp spacing for interpolation table
        iterations (int) : number of iterations to solve PDE
        """
        self.geometry = EquidistantRectGridEven(Lx, Ly, dx, dy)
        self.max_iter = iterations + 1
        self.relaxations = relaxations

        # TODO: move file caching logic to UnifiedMomentum object
        if cache_fn.exists():
            dps, xs, ps = load_cache(cache_fn)
        else:
            ps = []
            for relax in relaxations:
                dps, xs, _ps = self._generate_pressure_table(
                    ddp, 0.2, xmax=10, accumulate=True, relax=relax
                )
                ps.append(_ps)

            ps = np.min(ps, axis=0)

            save_cache(dps, xs, ps, cache_fn=cache_fn)

        # TODO: use scipy.interpolate.RectBivariateSpline
        self.interpolator = RegularGridInterpolator(
            [dps, xs], ps, bounds_error=False, fill_value=0
        )
